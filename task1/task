func singleNumber(nums []int) int {
    counts := make(map[int]int)
    for _,num := range nums{
        counts[num]++
    }
    for k,val := range counts{
        if(val ==1){
            return k
        }
    }
    return -1
}


func isPalindrome(x int) bool {
    if x<0 || x%10 ==0 && x!=0 {
        return false
    }
    revertedNumber := 0
    for x > revertedNumber{
        revertedNumber = revertedNumber*10 + x%10
        x = x/10
    }
    return x == revertedNumber || x == revertedNumber/10
}


func isValid(s string) bool {
    j := len(s)
    if j%2 ==1{
        return false
    }
    pairs := map[byte]byte{
        ')':'(',
        ']':'[',
        '}':'{',
    }
    stack := []byte{}
    for i:=0;i<j;i++{
        if pairs[s[i]]>0{
               if len(stack)==0 || stack[len(stack)-1] != pairs[s[i]]{
                return false
               }
               stack = stack[:len(stack)-1]
        }else{
            stack = append(stack,s[i])
        }
    }
    return len(stack) == 0
}


func longestCommonPrefix(strs []string) string {
    if len(strs) == 0{
        return ""
    } 
    var minLen int = len(strs[0])
    for i:=0;i<len(strs);i++{
        if(minLen>len(strs[i])){
            minLen = len(strs[i])
        }
    }
    var strjk string
    outer:
    for j:=0;j<minLen;j++{
        ch := strs[0][j]
          for k:=0;k<len(strs);k++{
            if(ch != strs[k][j]){
                break outer
            }
          }
          strjk += string(ch)
    }
    return strjk
}


func plusOne(digits []int) []int {
    numStr := ""
    for _,digit := range digits{
        numStr += strconv.Itoa(digit)
    }
    bigNum := new(big.Int)
    bigNum.SetString(numStr, 10)
    bigNum.Add(bigNum,big.NewInt(1))
    // 轉成字串再拆成陣列
    result := []int{}
    for _, ch := range bigNum.String() {
        d, _ := strconv.Atoi(string(ch))
        result = append(result, d)
    }

    return result
}



func removeDuplicates(nums []int) int {
    n := len(nums)
    if n==0 {
        return 0
    }
    slow := 1
    for fast := 1;fast<n; fast++{
        if nums[fast] != nums[fast-1]{
            nums[slow] = nums[fast]
            slow++
        }
    }
    return slow
}



func merge(intervals [][]int) [][]int {
    n := len(intervals)
	if n == 0 {
		return [][]int{}
	}
	//先对区间数组按照区间的起始位置进行排序
	for i := 0; i < n-1; i++ {
		for j := i + 1; j < n; j++ {
			//如果当前区间的起始位置大于下一个区间的起始位置，则交换两个区间的位置
			if intervals[i][0] > intervals[j][0] {
				intervals[i], intervals[j] = intervals[j], intervals[i]
			}
		}
	}
	//然后使用一个切片来存储合并后的区间，由于区间数组已经按照起始位置排序，所以可以直接从第一个区间开始合并
	merged := [][]int{intervals[0]}

	for i := 1; i < n; i++ {
		//如果当前区间的起始位置小于或等于上一个区间的结束位置，有重叠，合并两个区间
		if intervals[i][0] <= merged[len(merged)-1][1] {
			merged[len(merged)-1][1] = max(intervals[i][1], merged[len(merged)-1][1])
		} else {
			//如果没有重叠，则将当前区间添加到切片中
			//为什么要将没有重叠的假如切片中呢？因为有重叠的区间已经合并过了，没有重叠的区间可以直接添加到切片中
			merged = append(merged, intervals[i])
		}
	}
	return merged
}



func twoSum(nums []int, target int) []int {
    result := make([]int,2)
    n := len(nums)
    outter:
    for i := 0;i < n;i++{
        for j:=i+1;j<n;j++{
           if nums[i] + nums[j] == target{
            result[0]=i
            result[1]=j
            break outter
           }
        }
    }
    return result
}
